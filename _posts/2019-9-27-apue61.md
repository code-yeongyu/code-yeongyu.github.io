---
layout: post
title: Advanced Programming in the UNIX Environment - Process, Thread
date: 2019-9-27 23:49:22 +0900
categories: [unix, operating_system]
---

프로그램과 프로세스

# 프로그램
- "디스크의 디렉토리 안에있는 실행가능한 파일"
	- 메모리에 올려짐
	- 7개의 exec 중 하나의 결과값으로 커널에 의해 실행 될 수 있음(나중에 다루겠다, apue에서는 섹션 8.10에서 다룬다고 함)

# 프로세스와 프로세스 ID
## 프로세스
- 실행중인 프로그램을 **프로세스**라고 함
- 몇몇 운영체제에서는 task라고 부르기도 함

## 프로세스 ID
- 모든 프로세스가 갖는 고유한 숫자
- 늘 양수

**<자기 자신의 프로세스 id를 출력하는 코드>**
```c
#include "apue.h"

int main(void) {
	printf("hello world from pid %ld\n", (long)getpid());
	exit(0);
}
```
getpid 함수에 대해 이야기를 하자면,
- pid_t 자료형의 값을 반환하고, 사이즈는 정해져있지 않지만,
- 표준이 long integer의 사이즈에 맞을것을 보증한다.
	- 물론 대부분의 경우에서 int의 사이즈로도 괜찮을텐데, 호환성을 위해 long을 사용했다.

# 프로세스 제어
프로세스를 제어하기 위한 3개의 주요한 함수가 있다.
- fork
	- 자기 자신이 복제된 새 프로세스를 생성하는 함수
- exec (위에서 말했듯 7개의 종류가 있지만, 편의성을 위해 그냥 exec으로 통칭한다)
- waitpid

**<표준 입력에서 명령어를 받아오고, 실행시키는 간이 셸 프로그램>**
```c
#include "apue.h"
#include <sys/wait.h>

int main(void) {
	char buf[MAXLINE];
	pid_t pid;
	int status;
	printf("%% ");
	while (fgets(buf, MAXLINE, stdin) != NULL) {
		if(buf[strlen(buf) - 1] == '\n') // 끝자리가 엔터면
			buf[strlen(buf) - 1] = 0; // 엔터까지 명령어로 실행시키면 안되니까 null 로 만든다

		if((pid = fork()) < 0) // fork에 실패했다면
			err_sys("fork error");
		else if (pid == 0) { // fork 로 생성된 프로세스라면
			execlp(buf, buf, (char *)0); // 이 코드로 인하여 자식프로세스가 
			err_ret("couldn't execute: %s", buf);
			exit(127); // return code 127 means when shell failed to find the command that user have typed
		}
		/* parent */
		if ((pid = waitpid(pid, &status, 0)) < 0)
			err_sys("waitpid error");
		printf("%% ");
	}
	exit(0);
}
```

fork 함수의 반환값으로 세개의 경우를 구분해 볼 수 있는데,
- -1: 에러 발생
- 0: fork() 함수로 인해 생성된 프로세스가 fork 함수를 또 다시 호출 함
- 정상적인 pid: fork가 적절히 실행됨

fork되어 생성된 프로세스를 자식 프로세스, fork를 호출한 프로세스를 부모프로세스라고 하겠다.  
그래서 해당 코드를 분석해보자면,  
- 자식프로세스는 execlp로 명령어를 실행시키며 자기 자신을 실행된 해당 파일로 대체시킨다.
- 부모 프로세스는 명령어의 실행이 끝날 때까지 기달려야 하기 때문에(그래야 명령이 끝나고나서 명령어 입력을 받으니까) waitpid 함수를 통해서 기다린다.
	- waitpid의 반환값에는 프로그램의 상태를 알 수 있는 값이 있지만, 이 프로그램에서는 그런것들을 다루지는 않았다.
- 이 프로그램에는 문제점이 하나 있는데, 명령어에다가 인자값을 넘길 수 없다는 점이다.
	- 가령 ls를 실행한다 하더라도 어느 디렉토리에 ls를 할지 지정해 줄 수 없다.
	- 인자값을 넘기려면 스페이스나 탭 문자같은 것들로 인자값을 구분 해 준 뒤, 각각들을 execlp 의 매개변수로 전달해주는 방식으로 고쳐야한다.

# 쓰레드와 쓰레드ID
## 쓰레드
보통 프로그램은 쓰레드가 하나이다. 즉 한번에 하나의 기계어만 실행 된다.  
그러나, 멀티프로세서 시스템에서는 여러 쓰레드를 통해 병렬적으로 일을 처리 할 수 있다.
하나의 프로세스 안의 모든 쓰레드는
- 같은 주소 공간
- 같은 파일 서술자(file descriptor)
- 같은 스택
- 그외에 프로세스와 관련된 모든 속성
들을 공유한다.

각 쓰레드는 같은 프로세스 안에 속해있기 때문에 메모리의 스택공간을 공유한다. (즉 프로세스 a의 쓰레드 b는 쓰레드 c의 스택공간에 접근 할 수 있다!)  
그렇기 때문에 공유된 데이터끼리의 접근에 대해서 동기화를 시켜 줄 필요가있다.

## 쓰레드 ID
프로세스처럼, 쓰레드들은 ID를 통해 특정지어진다.  
물론 쓰레드들은 프로세스 각각에 한정지어 사용되기 때문에 지역변수처럼 한 프로세스는 자신의 쓰레드만 접근 할 수 있다.  
그래서 프로세스 A의 쓰레드 2는 프로세스 B에겐 어떠한 의미도 갖지않는다.  
쓰레드 ID는 프로세스 안에서 특정 쓰레드들을 능수능란하게 다루기 위해 사용한다.  
쓰레드는 유닉스 시스템에서 프로세스 모델이 생긴지 한참 뒤에 생겼기때문에 쓰레드 모델과 프로세스 모델은 복잡한 상호작용을 한다.